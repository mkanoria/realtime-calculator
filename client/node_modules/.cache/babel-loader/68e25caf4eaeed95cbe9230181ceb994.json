{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nvar name = 'usolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createUsolveAll = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = createSolveValidation({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [ [[8], [9]] ]\n   *\n   * See also:\n   *\n   *    usolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var R = _denseBackwardSubstitution(m, b);\n\n      return R.map(function (r) {\n        return r.valueOf();\n      });\n    }\n  });\n\n  function _denseBackwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/project/5e6c87c554a3190001a3fc93\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\n      return e[0];\n    })];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // loop columns backwards\n\n    for (var i = columns - 1; i >= 0; i--) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], M[i][i]);\n\n          for (var j = i - 1; j >= 0; j--) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = _toConsumableArray(b);\n\n          bNew[i] = 1;\n\n          for (var _j = i - 1; _j >= 0; _j--) {\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(function (x) {\n      return new DenseMatrix({\n        data: x.map(function (e) {\n          return [e];\n        }),\n        size: [rows, 1]\n      });\n    });\n  }\n\n  function _sparseBackwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\n      return e[0];\n    })];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // loop columns backwards\n\n    for (var i = columns - 1; i >= 0; i--) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k]; // values & indices (column i)\n\n        var iValues = [];\n        var iIndices = []; // first & last indeces in column\n\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1]; // find the value at [i, i]\n\n        var Mii = 0;\n\n        for (var j = lastIndex - 1; j >= firstIndex; j--) {\n          var J = index[j]; // check row\n\n          if (J === i) {\n            Mii = values[j];\n          } else if (J < i) {\n            // store upper triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], Mii); // loop upper triangular\n\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = _toConsumableArray(b);\n\n          bNew[i] = 1; // loop upper triangular\n\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(function (x) {\n      return new DenseMatrix({\n        data: x.map(function (e) {\n          return [e];\n        }),\n        size: [rows, 1]\n      });\n    });\n  }\n});","map":{"version":3,"sources":["/Users/mayankkanoria/Documents/Personal/calculator/node_modules/mathjs/es/function/algebra/solver/usolveAll.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","factory","createSolveValidation","dependencies","createUsolveAll","_ref","typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix","solveValidation","SparseMatrixArrayMatrix","m","b","_sparseBackwardSubstitution","DenseMatrixArrayMatrix","_denseBackwardSubstitution","ArrayArrayMatrix","a","R","map","r","valueOf","b_","B","_data","e","M","rows","_size","columns","L","k","j","splice","bNew","_j","push","x","data","size","values","_values","index","_index","ptr","_ptr","iValues","iIndices","firstIndex","lastIndex","Mii","J","_j2","_lastIndex","_J","_j3","_lastIndex2","_J2"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { factory } from '../../../utils/factory';\nimport { createSolveValidation } from './utils/solveValidation';\nvar name = 'usolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createUsolveAll = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var typed = _ref.typed,\n      matrix = _ref.matrix,\n      divideScalar = _ref.divideScalar,\n      multiplyScalar = _ref.multiplyScalar,\n      subtract = _ref.subtract,\n      equalScalar = _ref.equalScalar,\n      DenseMatrix = _ref.DenseMatrix;\n  var solveValidation = createSolveValidation({\n    DenseMatrix: DenseMatrix\n  });\n  /**\n   * Finds all solutions of a linear equation system by backward substitution. Matrix must be an upper triangular matrix.\n   *\n   * `U * x = b`\n   *\n   * Syntax:\n   *\n   *    math.usolve(U, b)\n   *\n   * Examples:\n   *\n   *    const a = [[-2, 3], [2, 1]]\n   *    const b = [11, 9]\n   *    const x = usolve(a, b)  // [ [[8], [9]] ]\n   *\n   * See also:\n   *\n   *    usolve, lup, slu, usolve, lusolve\n   *\n   * @param {Matrix, Array} U       A N x N matrix or array (U)\n   * @param {Matrix, Array} b       A column vector with the b values\n   *\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseBackwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseBackwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var R = _denseBackwardSubstitution(m, b);\n\n      return R.map(function (r) {\n        return r.valueOf();\n      });\n    }\n  });\n\n  function _denseBackwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/project/5e6c87c554a3190001a3fc93\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\n      return e[0];\n    })];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // loop columns backwards\n\n    for (var i = columns - 1; i >= 0; i--) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], M[i][i]);\n\n          for (var j = i - 1; j >= 0; j--) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = _toConsumableArray(b);\n\n          bNew[i] = 1;\n\n          for (var _j = i - 1; _j >= 0; _j--) {\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(function (x) {\n      return new DenseMatrix({\n        data: x.map(function (e) {\n          return [e];\n        }),\n        size: [rows, 1]\n      });\n    });\n  }\n\n  function _sparseBackwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(function (e) {\n      return e[0];\n    })];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // loop columns backwards\n\n    for (var i = columns - 1; i >= 0; i--) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k]; // values & indices (column i)\n\n        var iValues = [];\n        var iIndices = []; // first & last indeces in column\n\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1]; // find the value at [i, i]\n\n        var Mii = 0;\n\n        for (var j = lastIndex - 1; j >= firstIndex; j--) {\n          var J = index[j]; // check row\n\n          if (J === i) {\n            Mii = values[j];\n          } else if (J < i) {\n            // store upper triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], Mii); // loop upper triangular\n\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = _toConsumableArray(b);\n\n          bNew[i] = 1; // loop upper triangular\n\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(function (x) {\n      return new DenseMatrix({\n        data: x.map(function (e) {\n          return [e];\n        }),\n        size: [rows, 1]\n      });\n    });\n  }\n});"]},"metadata":{},"sourceType":"module"}